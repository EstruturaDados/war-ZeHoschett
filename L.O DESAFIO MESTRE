#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX 20

typedef struct {
    char nome[30];
    char tipo[20];
    int prioridade;
} Componente;

// Função para mostrar componentes
void mostrarComponentes(Componente comp[], int n) {
    printf("\n=== LISTA DE COMPONENTES ===\n");
    for (int i = 0; i < n; i++) {
        printf("%d. Nome: %s | Tipo: %s | Prioridade: %d\n", 
                i + 1, comp[i].nome, comp[i].tipo, comp[i].prioridade);
    }
}

// Bubble Sort por nome
int bubbleSortNome(Componente comp[], int n) {
    int comparacoes = 0;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            comparacoes++;
            if (strcmp(comp[j].nome, comp[j + 1].nome) > 0) {
                Componente temp = comp[j];
                comp[j] = comp[j + 1];
                comp[j + 1] = temp;
            }
        }
    }
    return comparacoes;
}

// Insertion Sort por tipo
int insertionSortTipo(Componente comp[], int n) {
    int comparacoes = 0;
    for (int i = 1; i < n; i++) {
        Componente chave = comp[i];
        int j = i - 1;
        while (j >= 0 && strcmp(comp[j].tipo, chave.tipo) > 0) {
            comp[j + 1] = comp[j];
            j--;
            comparacoes++;
        }
        comp[j + 1] = chave;
        comparacoes++;
    }
    return comparacoes;
}

// Selection Sort por prioridade
int selectionSortPrioridade(Componente comp[], int n) {
    int comparacoes = 0;
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++) {
            comparacoes++;
            if (comp[j].prioridade < comp[min].prioridade) {
                min = j;
            }
        }
        if (min != i) {
            Componente temp = comp[i];
            comp[i] = comp[min];
            comp[min] = temp;
        }
    }
    return comparacoes;
}

// Busca binária por nome
int buscaBinariaPorNome(Componente comp[], int n, char chave[]) {
    int inicio = 0, fim = n - 1, meio, comparacoes = 0;
    while (inicio <= fim) {
        meio = (inicio + fim) / 2;
        comparacoes++;
        int cmp = strcmp(comp[meio].nome, chave);
        if (cmp == 0) {
            printf("\nComponente '%s' encontrado!\n", chave);
            printf("Tipo: %s | Prioridade: %d\n", comp[meio].tipo, comp[meio].prioridade);
            return comparacoes;
        } else if (cmp < 0) {
            inicio = meio + 1;
        } else {
            fim = meio - 1;
        }
    }
    printf("\nComponente '%s' não encontrado.\n", chave);
    return comparacoes;
}

// Cópia de vetor para evitar interferência nos testes
void copiarVetor(Componente origem[], Componente destino[], int n) {
    for (int i = 0; i < n; i++)
        destino[i] = origem[i];
}

int main() {
    Componente componentes[MAX];
    int n = 0;
    int opcao;
    char nomeBusca[30];

    printf("===== SISTEMA DE TORRE DE FUGA =====\n");

    // Cadastro dos componentes
    printf("Quantos componentes deseja cadastrar (máx %d)? ", MAX);
    scanf("%d", &n);
    getchar();

    for (int i = 0; i < n; i++) {
        printf("\nComponente %d:\n", i + 1);
        printf("Nome: ");
        fgets(componentes[i].nome, 30, stdin);
        componentes[i].nome[strcspn(componentes[i].nome, "\n")] = '\0';

        printf("Tipo: ");
        fgets(componentes[i].tipo, 20, stdin);
        componentes[i].tipo[strcspn(componentes[i].tipo, "\n")] = '\0';

        printf("Prioridade (1-10): ");
        scanf("%d", &componentes[i].prioridade);
        getchar();
    }

    Componente copia[MAX];
    int compBubble, compInsertion, compSelection;
    double tempoBubble, tempoInsertion, tempoSelection;
    clock_t inicio, fim;

    // --- Bubble Sort (por nome) ---
    copiarVetor(componentes, copia, n);
    inicio = clock();
    compBubble = bubbleSortNome(copia, n);
    fim = clock();
    tempoBubble = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
    printf("\n[Bubble Sort - Nome] Tempo: %.5f s | Comparações: %d\n", tempoBubble, compBubble);

    // Busca binária
    printf("\nDigite o nome do componente-chave para busca binária: ");
    fgets(nomeBusca, 30, stdin);
    nomeBusca[strcspn(nomeBusca, "\n")] = '\0';
    int compBusca = buscaBinariaPorNome(copia, n, nomeBusca);
    printf("Comparações na busca binária: %d\n", compBusca);

    // --- Insertion Sort (por tipo) ---
    copiarVetor(componentes, copia, n);
    inicio = clock();
    compInsertion = insertionSortTipo(copia, n);
    fim = clock();
    tempoInsertion = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
    printf("\n[Insertion Sort - Tipo] Tempo: %.5f s | Comparações: %d\n", tempoInsertion, compInsertion);

    // --- Selection Sort (por prioridade) ---
    copiarVetor(componentes, copia, n);
    inicio = clock();
    compSelection = selectionSortPrioridade(copia, n);
    fim = clock();
    tempoSelection = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
    printf("\n[Selection Sort - Prioridade] Tempo: %.5f s | Comparações: %d\n", tempoSelection, compSelection);

    // --- Relatório Comparativo ---
    printf("\n================== RELATÓRIO DE DESEMPENHO ==================\n");
    printf("Algoritmo\t\tTempo (s)\tComparações\n");
    printf("-------------------------------------------------------------\n");
    printf("Bubble Sort (Nome)\t%.5f\t%d\n", tempoBubble, compBubble);
    printf("Insertion Sort (Tipo)\t%.5f\t%d\n", tempoInsertion, compInsertion);
    printf("Selection Sort (Prior)\t%.5f\t%d\n", tempoSelection, compSelection);
    printf("-------------------------------------------------------------\n");

    // Determinar o melhor algoritmo
    double menorTempo = tempoBubble;
    char melhorAlg[20] = "Bubble Sort";

    if (tempoInsertion < menorTempo) {
        menorTempo = tempoInsertion;
        strcpy(melhorAlg, "Insertion Sort");
    }
    if (tempoSelection < menorTempo) {
        menorTempo = tempoSelection;
        strcpy(melhorAlg, "Selection Sort");
    }

    printf("Melhor desempenho geral: %s (%.5f s)\n", melhorAlg, menorTempo);
    printf("=============================================================\n");

    return 0;
}
