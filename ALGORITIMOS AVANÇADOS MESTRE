/*
 Detective Quest - Versão Mestre
 - Árvore binária de salas (mapa da mansão)
 - BST para armazenar pistas coletadas (ordenadas)
 - Tabela hash que associa pista -> suspeito
 - Exploração interativa e fase de acusação/validação

 Compile:
   gcc -o detective detective.c
 Execute:
   ./detective
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_NOME 80
#define MAX_PISTA 200
#define HASH_SIZE 101   // número de buckets da tabela hash (primo simples)

// --------------------------
// Estruturas de dados
// --------------------------

// Nó da árvore de salas (mapa)
typedef struct Sala {
    char nome[MAX_NOME];
    char pista[MAX_PISTA]; // pista estática associada à sala (pode ser string vazia)
    struct Sala *esquerda;
    struct Sala *direita;
} Sala;

// Nó da BST de pistas coletadas (ordenada por string)
typedef struct PistaNode {
    char pista[MAX_PISTA];
    struct PistaNode *esquerda;
    struct PistaNode *direita;
} PistaNode;

// Entrada da tabela hash: chave = pista, valor = nome do suspeito
typedef struct HashEntry {
    char pista[MAX_PISTA];
    char suspeito[MAX_NOME];
    struct HashEntry *next; // para resolução por encadeamento
} HashEntry;

// --------------------------
// Funções - criação e utilitários
// --------------------------

// Função auxiliar: remove '\n' de string vinda de fgets
void trim_newline(char *s) {
    size_t len = strlen(s);
    if (len == 0) return;
    if (s[len-1] == '\n') s[len-1] = '\0';
}

// ================================
// criarSala()
// Cria dinamicamente um cômodo (Sala) com nome e pista.
// ================================
Sala* criarSala(const char *nome, const char *pista) {
    Sala *s = (Sala*) malloc(sizeof(Sala));
    if (!s) {
        fprintf(stderr, "Erro de alocação em criarSala\n");
        exit(1);
    }
    strncpy(s->nome, nome, MAX_NOME-1);
    s->nome[MAX_NOME-1] = '\0';
    if (pista && strlen(pista) > 0) {
        strncpy(s->pista, pista, MAX_PISTA-1);
        s->pista[MAX_PISTA-1] = '\0';
    } else {
        s->pista[0] = '\0';
    }
    s->esquerda = s->direita = NULL;
    return s;
}

// ================================
// criarPistaNode()
// Cria um nó para a BST de pistas.
// ================================
PistaNode* criarPistaNode(const char *pista) {
    PistaNode *n = (PistaNode*) malloc(sizeof(PistaNode));
    if (!n) {
        fprintf(stderr, "Erro de alocação em criarPistaNode\n");
        exit(1);
    }
    strncpy(n->pista, pista, MAX_PISTA-1);
    n->pista[MAX_PISTA-1] = '\0';
    n->esquerda = n->direita = NULL;
    return n;
}

// --------------------------
// BST de pistas: inserir e percorrer
// --------------------------

// inserirPista()
// Insere uma nova pista na BST em ordem alfabética.
// Não insere duplicatas (se já existir a mesma string).
PistaNode* inserirPista(PistaNode *raiz, const char *pista) {
    if (raiz == NULL) {
        return criarPistaNode(pista);
    }
    int cmp = strcmp(pista, raiz->pista);
    if (cmp < 0) {
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    } else if (cmp > 0) {
        raiz->direita = inserirPista(raiz->direita, pista);
    } // se cmp == 0: duplicata => não insere
    return raiz;
}

// adicionarPista()
// Wrapper: adiciona pista só se não vazia.
PistaNode* adicionarPista(PistaNode *raiz, const char *pista) {
    if (pista == NULL || strlen(pista) == 0) return raiz;
    return inserirPista(raiz, pista);
}

// exibirPistasInOrder()
// Exibe todas as pistas coletadas em ordem alfabética (in-order traversal)
void exibirPistasInOrder(PistaNode *raiz) {
    if (!raiz) return;
    exibirPistasInOrder(raiz->esquerda);
    printf(" - %s\n", raiz->pista);
    exibirPistasInOrder(raiz->direita);
}

// libera BST de pistas
void liberarPistaTree(PistaNode *raiz) {
    if (!raiz) return;
    liberarPistaTree(raiz->esquerda);
    liberarPistaTree(raiz->direita);
    free(raiz);
}

// --------------------------
// Tabela hash: funções
// --------------------------

// hash function: djb2 (string -> unsigned long), mod HASH_SIZE
unsigned long hash_str(const char *str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++))
        hash = ((hash << 5) + hash) + (unsigned char)c; /* hash * 33 + c */
    return hash % HASH_SIZE;
}

// inserirNaHash()
// Insere associação pista -> suspeito na tabela hash.
// Se a pista já existir, substitui o suspeito (não esperado, mas seguro).
void inserirNaHash(HashEntry *table[], const char *pista, const char *suspeito) {
    unsigned long idx = hash_str(pista);
    HashEntry *head = table[idx];
    // procurar se já existe
    for (HashEntry *e = head; e != NULL; e = e->next) {
        if (strcmp(e->pista, pista) == 0) {
            strncpy(e->suspeito, suspeito, MAX_NOME-1);
            e->suspeito[MAX_NOME-1] = '\0';
            return;
        }
    }
    // inserir novo entry no início
    HashEntry *novo = (HashEntry*) malloc(sizeof(HashEntry));
    if (!novo) {
        fprintf(stderr, "Erro de alocação inserirNaHash\n");
        exit(1);
    }
    strncpy(novo->pista, pista, MAX_PISTA-1);
    novo->pista[MAX_PISTA-1] = '\0';
    strncpy(novo->suspeito, suspeito, MAX_NOME-1);
    novo->suspeito[MAX_NOME-1] = '\0';
    novo->next = head;
    table[idx] = novo;
}

// encontrarSuspeito()
// Consulta a tabela hash por uma pista; retorna nome do suspeito ou NULL se não achar.
char* encontrarSuspeito(HashEntry *table[], const char *pista) {
    unsigned long idx = hash_str(pista);
    for (HashEntry *e = table[idx]; e != NULL; e = e->next) {
        if (strcmp(e->pista, pista) == 0) {
            return e->suspeito;
        }
    }
    return NULL;
}

// libera tabela hash
void liberarHash(HashEntry *table[]) {
    for (int i = 0; i < HASH_SIZE; ++i) {
        HashEntry *e = table[i];
        while (e) {
            HashEntry *tmp = e->next;
            free(e);
            e = tmp;
        }
        table[i] = NULL;
    }
}

// --------------------------
// Exploração da mansão
// --------------------------

// explorarSalas()
// Navega recursivamente (modo interativo) pela árvore de salas.
// Ao entrar numa sala, exibe e coleta a pista (adicionando à BST de pistas).
// Parâmetros:
//   atual  - nó atual (Sala*)
//   pistas - ponteiro para raiz da BST de pistas coletadas (PistaNode**)
void explorarSalas(Sala *atual, PistaNode **pistas) {
    if (!atual) return;
    char opcao;

    printf("\nVocê está no cômodo: %s\n", atual->nome);

    // se houver pista, coleta automaticamente (adiciona na BST)
    if (strlen(atual->pista) > 0) {
        printf("Pista encontrada: \"%s\"\n", atual->pista);
        *pistas = adicionarPista(*pistas, atual->pista);
    } else {
        printf("Nenhuma pista neste cômodo.\n");
    }

    while (1) {
        printf("\nEscolha:\n");
        if (atual->esquerda) printf(" [e] Ir para %s (esquerda)\n", atual->esquerda->nome);
        if (atual->direita) printf(" [d] Ir para %s (direita)\n", atual->direita->nome);
        printf(" [s] Voltar / Sair desta rota\n");
        printf("Opção: ");
        if (scanf(" %c", &opcao) != 1) {
            while (getchar() != '\n'); // limpar stdin
            printf("Entrada inválida\n");
            continue;
        }

        if ((opcao == 'e' || opcao == 'E') && atual->esquerda) {
            explorarSalas(atual->esquerda, pistas);
            printf("\n(Voltando para %s)\n", atual->nome);
            return; // após explorar retorno ao nó anterior
        } else if ((opcao == 'd' || opcao == 'D') && atual->direita) {
            explorarSalas(atual->direita, pistas);
            printf("\n(Voltando para %s)\n", atual->nome);
            return;
        } else if (opcao == 's' || opcao == 'S') {
            // retorna ao nível anterior (ou termina se estiver na raiz)
            return;
        } else {
            printf("Opção inválida ou caminho inexistente. Tente novamente.\n");
        }
    }
}

// --------------------------
// Fase de julgamento
// --------------------------

// contarPistasParaSuspeito()
// Percorre a BST de pistas e conta quantas pistas apontam para 'suspeitoAlvo'
// usando a tabela hash (pista->suspeito). Retorna contador.
int contarPistasParaSuspeito(PistaNode *raiz, HashEntry *table[], const char *suspeitoAlvo) {
    if (!raiz) return 0;
    int contador = 0;
    // verificar esquerda
    contador += contarPistasParaSuspeito(raiz->esquerda, table, suspeitoAlvo);
    // verificar este nó
    char *s = encontrarSuspeito(table, raiz->pista);
    if (s != NULL && strcasecmp(s, suspeitoAlvo) == 0) {
        contador++;
    }
    // direita
    contador += contarPistasParaSuspeito(raiz->direita, table, suspeitoAlvo);
    return contador;
}

// verificarSuspeitoFinal()
// Solicita ao jogador a acusação final (nome do suspeito) e valida se há >= 2 pistas.
// Exibe mensagens correspondentes.
void verificarSuspeitoFinal(PistaNode *pistas, HashEntry *table[]) {
    char acusado[MAX_NOME];
    printf("\nQuem você acusa? Digite o nome do suspeito: ");
    // limpar buffer antes de fgets
    while (getchar() != '\n'); // consome resto da linha
    if (!fgets(acusado, sizeof(acusado), stdin)) {
        printf("Leitura falhou.\n");
        return;
    }
    trim_newline(acusado);
    if (strlen(acusado) == 0) {
        printf("Nome inválido.\n");
        return;
    }

    int cont = contarPistasParaSuspeito(pistas, table, acusado);
    printf("\nNúmero de pistas apontando para %s: %d\n", acusado, cont);

    if (cont >= 2) {
        printf("\nDESFECHO: Acusação aceita!\n");
        printf("Há evidências suficientes para sustentar a acusação contra %s.\n", acusado);
    } else {
        printf("\nDESFECHO: Acusação rejeitada.\n");
        printf("Não há pistas suficientes (é necessário pelo menos 2 pistas associadas).\n");
    }
}

// --------------------------
// Limpeza e utilitários
// --------------------------

void liberarSalas(Sala *raiz) {
    if (!raiz) return;
    liberarSalas(raiz->esquerda);
    liberarSalas(raiz->direita);
    free(raiz);
}

// --------------------------
// main: montagem do mapa, hash de pistas -> suspeito, fluxo do jogo
// --------------------------
int main() {
    // ---------- Montagem fixa do mapa (árvore de salas) ----------
    /*
      
    Sala *hall = criarSala("Hall de Entrada", "Pegada úmida próximo ao tapete.");
    Sala *salaEstar = criarSala("Sala de Estar", "Relógio parado às 03:15.");
    Sala *cozinha = criarSala("Cozinha", "Xícara com resquício de um aroma raro.");
    Sala *biblioteca = criarSala("Biblioteca", "Livro sobre venenos na prateleira.");
    Sala *jardim = criarSala("Jardim", "Pegadas levando ao portão lateral.");
    Sala *porao = criarSala("Porão", "Casaco molhado escondido atrás de caixas.");

    // ligações
    hall->esquerda = salaEstar;
    hall->direita = cozinha;
    salaEstar->esquerda = biblioteca;
    salaEstar->direita = jardim;
    cozinha->direita = porao;

    // ---------- Montagem da tabela hash pista -> suspeito ----------
    HashEntry *tabela[HASH_SIZE];
    for (int i = 0; i < HASH_SIZE; ++i) tabela[i] = NULL;

    // Definimos associações (pista -> suspeito) baseadas nas pistas estáticas acima.
    // (No jogo real, essas associações podem ser mais complexas; aqui estão fixas.)
    inserirNaHash(tabela, "Pegada úmida próximo ao tapete.", "Sr. Almeida");
    inserirNaHash(tabela, "Relógio parado às 03:15.", "Sra. Oliveira");
    inserirNaHash(tabela, "Xícara com resquício de um aroma raro.", "Sr. Almeida");
    inserirNaHash(tabela, "Livro sobre venenos na prateleira.", "Dr. Castro");
    inserirNaHash(tabela, "Pegadas levando ao portão lateral.", "Sra. Oliveira");
    inserirNaHash(tabela, "Casaco molhado escondido atrás de caixas.", "Sr. Almeida");

    // ---------- BST de pistas coletadas (inicialmente vazia) ----------
    PistaNode *pistasColetadas = NULL;

    // ---------- Interação com o jogador ----------
    printf("=============================================\n");
    printf("   DETECTIVE QUEST - Julgamento Final\n");
    printf("=============================================\n");
    printf("Explore a mansão, colete pistas e acuse o culpado.\n");
    printf("Navegue a partir do Hall de Entrada.\n");

    // Loop para permitir explorar diversas rotas até o jogador escolher encerrar no menu principal
    char opcaoMenu = 0;
    while (1) {
        printf("\nMenu principal:\n");
        printf(" [i] Iniciar/Continuar exploração a partir do Hall\n");
        printf(" [l] Listar pistas coletadas (ordenadas)\n");
        printf(" [a] Acusar um suspeito (fase de julgamento)\n");
        printf(" [q] Sair do jogo\n");
        printf("Opção: ");
        if (scanf(" %c", &opcaoMenu) != 1) {
            while (getchar() != '\n'); // limpar
            continue;
        }

        if (opcaoMenu == 'i' || opcaoMenu == 'I') {
            explorarSalas(hall, &pistasColetadas);
            printf("\nRetornando ao menu principal.\n");
        } else if (opcaoMenu == 'l' || opcaoMenu == 'L') {
            printf("\nPistas coletadas (ordem alfabética):\n");
            if (!pistasColetadas) {
                printf(" (nenhuma pista coletada ainda)\n");
            } else {
                exibirPistasInOrder(pistasColetadas);
            }
        } else if (opcaoMenu == 'a' || opcaoMenu == 'A') {
            if (!pistasColetadas) {
                printf("\nVocê ainda não coletou pistas. Explore a mansão antes de acusar.\n");
            } else {
                // exibe as pistas antes da acusação
                printf("\nPistas coletadas (para consulta antes de acusar):\n");
                exibirPistasInOrder(pistasColetadas);
                verificarSuspeitoFinal(pistasColetadas, tabela);
            }
        } else if (opcaoMenu == 'q' || opcaoMenu == 'Q') {
            printf("\nEncerrando o jogo. Obrigado por jogar!\n");
            break;
        } else {
            printf("Opção inválida. Tente novamente.\n");
        }
    }

    // ---------- limpeza ----------
    liberarSalas(hall);
    liberarPistaTree(pistasColetadas);
    liberarHash(tabela);

    return 0;
}
