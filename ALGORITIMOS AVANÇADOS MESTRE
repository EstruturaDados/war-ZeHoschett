/*
 Detective Quest - Vers√£o Mestre
 - √Årvore bin√°ria de salas (mapa da mans√£o)
 - BST para armazenar pistas coletadas (ordenadas)
 - Tabela hash que associa pista -> suspeito
 - Explora√ß√£o interativa e fase de acusa√ß√£o/valida√ß√£o

 Compile:
   gcc -o detective detective.c
 Execute:
   ./detective
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_NOME 80
#define MAX_PISTA 200
#define HASH_SIZE 101   // n√∫mero de buckets da tabela hash (primo simples)

// --------------------------
// Estruturas de dados
// --------------------------

// N√≥ da √°rvore de salas (mapa)
typedef struct Sala {
    char nome[MAX_NOME];
    char pista[MAX_PISTA]; // pista est√°tica associada √† sala (pode ser string vazia)
    struct Sala *esquerda;
    struct Sala *direita;
} Sala;

// N√≥ da BST de pistas coletadas (ordenada por string)
typedef struct PistaNode {
    char pista[MAX_PISTA];
    struct PistaNode *esquerda;
    struct PistaNode *direita;
} PistaNode;

// Entrada da tabela hash: chave = pista, valor = nome do suspeito
typedef struct HashEntry {
    char pista[MAX_PISTA];
    char suspeito[MAX_NOME];
    struct HashEntry *next; // para resolu√ß√£o por encadeamento
} HashEntry;

// --------------------------
// Fun√ß√µes - cria√ß√£o e utilit√°rios
// --------------------------

// Fun√ß√£o auxiliar: remove '\n' de string vinda de fgets
void trim_newline(char *s) {
    size_t len = strlen(s);
    if (len == 0) return;
    if (s[len-1] == '\n') s[len-1] = '\0';
}

// ================================
// criarSala()
// Cria dinamicamente um c√¥modo (Sala) com nome e pista.
// ================================
Sala* criarSala(const char *nome, const char *pista) {
    Sala *s = (Sala*) malloc(sizeof(Sala));
    if (!s) {
        fprintf(stderr, "Erro de aloca√ß√£o em criarSala\n");
        exit(1);
    }
    strncpy(s->nome, nome, MAX_NOME-1);
    s->nome[MAX_NOME-1] = '\0';
    if (pista && strlen(pista) > 0) {
        strncpy(s->pista, pista, MAX_PISTA-1);
        s->pista[MAX_PISTA-1] = '\0';
    } else {
        s->pista[0] = '\0';
    }
    s->esquerda = s->direita = NULL;
    return s;
}

// ================================
// criarPistaNode()
// Cria um n√≥ para a BST de pistas.
// ================================
PistaNode* criarPistaNode(const char *pista) {
    PistaNode *n = (PistaNode*) malloc(sizeof(PistaNode));
    if (!n) {
        fprintf(stderr, "Erro de aloca√ß√£o em criarPistaNode\n");
        exit(1);
    }
    strncpy(n->pista, pista, MAX_PISTA-1);
    n->pista[MAX_PISTA-1] = '\0';
    n->esquerda = n->direita = NULL;
    return n;
}

// --------------------------
// BST de pistas: inserir e percorrer
// --------------------------

// inserirPista()
// Insere uma nova pista na BST em ordem alfab√©tica.
// N√£o insere duplicatas (se j√° existir a mesma string).
PistaNode* inserirPista(PistaNode *raiz, const char *pista) {
    if (raiz == NULL) {
        return criarPistaNode(pista);
    }
    int cmp = strcmp(pista, raiz->pista);
    if (cmp < 0) {
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    } else if (cmp > 0) {
        raiz->direita = inserirPista(raiz->direita, pista);
    } // se cmp == 0: duplicata => n√£o insere
    return raiz;
}

// adicionarPista()
// Wrapper: adiciona pista s√≥ se n√£o vazia.
PistaNode* adicionarPista(PistaNode *raiz, const char *pista) {
    if (pista == NULL || strlen(pista) == 0) return raiz;
    return inserirPista(raiz, pista);
}

// exibirPistasInOrder()
// Exibe todas as pistas coletadas em ordem alfab√©tica (in-order traversal)
void exibirPistasInOrder(PistaNode *raiz) {
    if (!raiz) return;
    exibirPistasInOrder(raiz->esquerda);
    printf(" - %s\n", raiz->pista);
    exibirPistasInOrder(raiz->direita);
}

// libera BST de pistas
void liberarPistaTree(PistaNode *raiz) {
    if (!raiz) return;
    liberarPistaTree(raiz->esquerda);
    liberarPistaTree(raiz->direita);
    free(raiz);
}

// --------------------------
// Tabela hash: fun√ß√µes
// --------------------------

// hash function: djb2 (string -> unsigned long), mod HASH_SIZE
unsigned long hash_str(const char *str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++))
        hash = ((hash << 5) + hash) + (unsigned char)c; /* hash * 33 + c */
    return hash % HASH_SIZE;
}

// inserirNaHash()
// Insere associa√ß√£o pista -> suspeito na tabela hash.
// Se a pista j√° existir, substitui o suspeito (n√£o esperado, mas seguro).
void inserirNaHash(HashEntry *table[], const char *pista, const char *suspeito) {
    unsigned long idx = hash_str(pista);
    HashEntry *head = table[idx];
    // procurar se j√° existe
    for (HashEntry *e = head; e != NULL; e = e->next) {
        if (strcmp(e->pista, pista) == 0) {
            strncpy(e->suspeito, suspeito, MAX_NOME-1);
            e->suspeito[MAX_NOME-1] = '\0';
            return;
        }
    }
    // inserir novo entry no in√≠cio
    HashEntry *novo = (HashEntry*) malloc(sizeof(HashEntry));
    if (!novo) {
        fprintf(stderr, "Erro de aloca√ß√£o inserirNaHash\n");
        exit(1);
    }
    strncpy(novo->pista, pista, MAX_PISTA-1);
    novo->pista[MAX_PISTA-1] = '\0';
    strncpy(novo->suspeito, suspeito, MAX_NOME-1);
    novo->suspeito[MAX_NOME-1] = '\0';
    novo->next = head;
    table[idx] = novo;
}

// encontrarSuspeito()
// Consulta a tabela hash por uma pista; retorna nome do suspeito ou NULL se n√£o achar.
char* encontrarSuspeito(HashEntry *table[], const char *pista) {
    unsigned long idx = hash_str(pista);
    for (HashEntry *e = table[idx]; e != NULL; e = e->next) {
        if (strcmp(e->pista, pista) == 0) {
            return e->suspeito;
        }
    }
    return NULL;
}

// libera tabela hash
void liberarHash(HashEntry *table[]) {
    for (int i = 0; i < HASH_SIZE; ++i) {
        HashEntry *e = table[i];
        while (e) {
            HashEntry *tmp = e->next;
            free(e);
            e = tmp;
        }
        table[i] = NULL;
    }
}

// --------------------------
// Explora√ß√£o da mans√£o
// --------------------------

// explorarSalas()
// Navega recursivamente (modo interativo) pela √°rvore de salas.
// Ao entrar numa sala, exibe e coleta a pista (adicionando √† BST de pistas).
// Par√¢metros:
//   atual  - n√≥ atual (Sala*)
//   pistas - ponteiro para raiz da BST de pistas coletadas (PistaNode**)
void explorarSalas(Sala *atual, PistaNode **pistas) {
    if (!atual) return;
    char opcao;

    printf("\nVoc√™ est√° no c√¥modo: %s\n", atual->nome);

    // se houver pista, coleta automaticamente (adiciona na BST)
    if (strlen(atual->pista) > 0) {
        printf("Pista encontrada: \"%s\"\n", atual->pista);
        *pistas = adicionarPista(*pistas, atual->pista);
    } else {
        printf("Nenhuma pista neste c√¥modo.\n");
    }

    while (1) {
        printf("\nEscolha:\n");
        if (atual->esquerda) printf(" [e] Ir para %s (esquerda)\n", atual->esquerda->nome);
        if (atual->direita) printf(" [d] Ir para %s (direita)\n", atual->direita->nome);
        printf(" [s] Voltar / Sair desta rota\n");
        printf("Op√ß√£o: ");
        if (scanf(" %c", &opcao) != 1) {
            while (getchar() != '\n'); // limpar stdin
            printf("Entrada inv√°lida\n");
            continue;
        }

        if ((opcao == 'e' || opcao == 'E') && atual->esquerda) {
            explorarSalas(atual->esquerda, pistas);
            printf("\n(Voltando para %s)\n", atual->nome);
            return; // ap√≥s explorar retorno ao n√≥ anterior
        } else if ((opcao == 'd' || opcao == 'D') && atual->direita) {
            explorarSalas(atual->direita, pistas);
            printf("\n(Voltando para %s)\n", atual->nome);
            return;
        } else if (opcao == 's' || opcao == 'S') {
            // retorna ao n√≠vel anterior (ou termina se estiver na raiz)
            return;
        } else {
            printf("Op√ß√£o inv√°lida ou caminho inexistente. Tente novamente.\n");
        }
    }
}

// --------------------------
// Fase de julgamento
// --------------------------

// contarPistasParaSuspeito()
// Percorre a BST de pistas e conta quantas pistas apontam para 'suspeitoAlvo'
// usando a tabela hash (pista->suspeito). Retorna contador.
int contarPistasParaSuspeito(PistaNode *raiz, HashEntry *table[], const char *suspeitoAlvo) {
    if (!raiz) return 0;
    int contador = 0;
    // verificar esquerda
    contador += contarPistasParaSuspeito(raiz->esquerda, table, suspeitoAlvo);
    // verificar este n√≥
    char *s = encontrarSuspeito(table, raiz->pista);
    if (s != NULL && strcasecmp(s, suspeitoAlvo) == 0) {
        contador++;
    }
    // direita
    contador += contarPistasParaSuspeito(raiz->direita, table, suspeitoAlvo);
    return contador;
}

// verificarSuspeitoFinal()
// Solicita ao jogador a acusa√ß√£o final (nome do suspeito) e valida se h√° >= 2 pistas.
// Exibe mensagens correspondentes.
void verificarSuspeitoFinal(PistaNode *pistas, HashEntry *table[]) {
    char acusado[MAX_NOME];
    printf("\nQuem voc√™ acusa? Digite o nome do suspeito: ");
    // limpar buffer antes de fgets
    while (getchar() != '\n'); // consome resto da linha
    if (!fgets(acusado, sizeof(acusado), stdin)) {
        printf("Leitura falhou.\n");
        return;
    }
    trim_newline(acusado);
    if (strlen(acusado) == 0) {
        printf("Nome inv√°lido.\n");
        return;
    }

    int cont = contarPistasParaSuspeito(pistas, table, acusado);
    printf("\nN√∫mero de pistas apontando para %s: %d\n", acusado, cont);

    if (cont >= 2) {
        printf("\nDESFECHO: Acusa√ß√£o aceita!\n");
        printf("H√° evid√™ncias suficientes para sustentar a acusa√ß√£o contra %s.\n", acusado);
    } else {
        printf("\nDESFECHO: Acusa√ß√£o rejeitada.\n");
        printf("N√£o h√° pistas suficientes (√© necess√°rio pelo menos 2 pistas associadas).\n");
    }
}

// --------------------------
// Limpeza e utilit√°rios
// --------------------------

void liberarSalas(Sala *raiz) {
    if (!raiz) return;
    liberarSalas(raiz->esquerda);
    liberarSalas(raiz->direita);
    free(raiz);
}

// --------------------------
// main: montagem do mapa, hash de pistas -> suspeito, fluxo do jogo
// --------------------------
int main() {
    // ---------- Montagem fixa do mapa (√°rvore de salas) ----------
    /*
           Hall
           /  \
        Estar  Cozinha
        /  \      \
     Biblioteca Jardim Por√£o
    */
    Sala *hall = criarSala("Hall de Entrada", "Pegada √∫mida pr√≥ximo ao tapete.");
    Sala *salaEstar = criarSala("Sala de Estar", "Rel√≥gio parado √†s 03:15.");
    Sala *cozinha = criarSala("Cozinha", "X√≠cara com resqu√≠cio de um aroma raro.");
    Sala *biblioteca = criarSala("Biblioteca", "Livro sobre venenos na prateleira.");
    Sala *jardim = criarSala("Jardim", "Pegadas levando ao port√£o lateral.");
    Sala *porao = criarSala("Por√£o", "Casaco molhado escondido atr√°s de caixas.");

    // liga√ß√µes
    hall->esquerda = salaEstar;
    hall->direita = cozinha;
    salaEstar->esquerda = biblioteca;
    salaEstar->direita = jardim;
    cozinha->direita = porao;

    // ---------- Montagem da tabela hash pista -> suspeito ----------
    HashEntry *tabela[HASH_SIZE];
    for (int i = 0; i < HASH_SIZE; ++i) tabela[i] = NULL;

    // Definimos associa√ß√µes (pista -> suspeito) baseadas nas pistas est√°ticas acima.
    // (No jogo real, essas associa√ß√µes podem ser mais complexas; aqui est√£o fixas.)
    inserirNaHash(tabela, "Pegada √∫mida pr√≥ximo ao tapete.", "Sr. Almeida");
    inserirNaHash(tabela, "Rel√≥gio parado √†s 03:15.", "Sra. Oliveira");
    inserirNaHash(tabela, "X√≠cara com resqu√≠cio de um aroma raro.", "Sr. Almeida");
    inserirNaHash(tabela, "Livro sobre venenos na prateleira.", "Dr. Castro");
    inserirNaHash(tabela, "Pegadas levando ao port√£o lateral.", "Sra. Oliveira");
    inserirNaHash(tabela, "Casaco molhado escondido atr√°s de caixas.", "Sr. Almeida");

    // ---------- BST de pistas coletadas (inicialmente vazia) ----------
    PistaNode *pistasColetadas = NULL;

    // ---------- Intera√ß√£o com o jogador ----------
    printf("=============================================\n");
    printf("  üé© DETECTIVE QUEST - Julgamento Final\n");
    printf("=============================================\n");
    printf("Explore a mans√£o, colete pistas e acuse o culpado.\n");
    printf("Navegue a partir do Hall de Entrada.\n");

    // Loop para permitir explorar diversas rotas at√© o jogador escolher encerrar no menu principal
    char opcaoMenu = 0;
    while (1) {
        printf("\nMenu principal:\n");
        printf(" [i] Iniciar/Continuar explora√ß√£o a partir do Hall\n");
        printf(" [l] Listar pistas coletadas (ordenadas)\n");
        printf(" [a] Acusar um suspeito (fase de julgamento)\n");
        printf(" [q] Sair do jogo\n");
        printf("Op√ß√£o: ");
        if (scanf(" %c", &opcaoMenu) != 1) {
            while (getchar() != '\n'); // limpar
            continue;
        }

        if (opcaoMenu == 'i' || opcaoMenu == 'I') {
            explorarSalas(hall, &pistasColetadas);
            printf("\nRetornando ao menu principal.\n");
        } else if (opcaoMenu == 'l' || opcaoMenu == 'L') {
            printf("\nPistas coletadas (ordem alfab√©tica):\n");
            if (!pistasColetadas) {
                printf(" (nenhuma pista coletada ainda)\n");
            } else {
                exibirPistasInOrder(pistasColetadas);
            }
        } else if (opcaoMenu == 'a' || opcaoMenu == 'A') {
            if (!pistasColetadas) {
                printf("\nVoc√™ ainda n√£o coletou pistas. Explore a mans√£o antes de acusar.\n");
            } else {
                // exibe as pistas antes da acusa√ß√£o
                printf("\nPistas coletadas (para consulta antes de acusar):\n");
                exibirPistasInOrder(pistasColetadas);
                verificarSuspeitoFinal(pistasColetadas, tabela);
            }
        } else if (opcaoMenu == 'q' || opcaoMenu == 'Q') {
            printf("\nEncerrando o jogo. Obrigado por jogar!\n");
            break;
        } else {
            printf("Op√ß√£o inv√°lida. Tente novamente.\n");
        }
    }

    // ---------- limpeza ----------
    liberarSalas(hall);
    liberarPistaTree(pistasColetadas);
    liberarHash(tabela);

    return 0;
}
